#!/usr/bin/env bash
set -euo pipefail

############################################
# Configuration Constants
############################################
DOMAIN="testsanctum01.zero1.network"
EMAIL="sanctum@rizzn.com"
LETTAPASS="yourpassword"

# Docker Configuration
LETTA_IMAGE="letta/letta:latest"
LETTA_HOST_PORT="8284"
LETTA_CONTAINER_PORT="8283"
LETTA_DATA_DIR="~/.letta/.persist/pgdata"

# Nginx Configuration
NGINX_SITES_AVAILABLE="/etc/nginx/sites-available"
NGINX_SITES_ENABLED="/etc/nginx/sites-enabled"

# API Keys (these can be customized)
OPENAI_API_KEY="dummy"
ANTHROPIC_API_KEY="dummy"
OLLAMA_BASE_URL="http://host.docker.internal:11434"

# Screen Session Name
SCREEN_SESSION="letta"

# Normalize paths that contain ~
LETTA_DATA_DIR=${LETTA_DATA_DIR/#\~/$HOME}

############################################
# 1. Install system packages
############################################
apt-get update
apt-get install -y nginx docker.io certbot python3-certbot-nginx

# Enable services to start on boot
echo "Enabling services to start on boot..."
systemctl enable docker
systemctl enable nginx
echo "‚úî Services enabled for auto-start"

############################################
# 1a. Install Python and create Sanctum venv
############################################
echo "Setting up Python environment for Sanctum..."
apt-get install -y python3 python3-venv python3-pip

# Create Sanctum virtual environment
python3 -m venv ~/sanctum/venv
~/sanctum/venv/bin/pip install --upgrade pip wheel
~/sanctum/venv/bin/pip install flask

echo "‚úî Python environment and Flask installed"

############################################
# 2. Letta persistent volume + .env
############################################
mkdir -p $LETTA_DATA_DIR
cat > ~/.letta/.env <<EOF
OPENAI_API_KEY="$OPENAI_API_KEY"
ANTHROPIC_API_KEY="$ANTHROPIC_API_KEY"
OLLAMA_BASE_URL="$OLLAMA_BASE_URL"
LETTA_SERVER_PASSWORD="$LETTAPASS"
EOF

############################################
# 3. Run Letta detached in screen (host 8284 ‚Üí container 8283)
############################################
echo "Launching Letta container in background..."
screen -dmS $SCREEN_SESSION docker run \
  -v $LETTA_DATA_DIR:/var/lib/postgresql/data \
  -p $LETTA_HOST_PORT:$LETTA_CONTAINER_PORT \
  --env-file ~/.letta/.env \
  -e SECURE=true \
  -e LETTA_SERVER_PASSWORD=$LETTAPASS \
  --add-host=host.docker.internal:host-gateway \
  $LETTA_IMAGE

echo "‚úî Letta container launched (starting up in background)"

############################################
# 3a. Create Sanctum folder structure
############################################
echo "Creating Sanctum folder structure..."
mkdir -p ~/sanctum/{venv,agents,smcp,control/{web,run,cron}}
mkdir -p ~/sanctum/control/run/{agent-athena,agent-monday,agent-timbre}
mkdir -p ~/sanctum/control/run/agent-athena/{broca2,thalamus}
mkdir -p ~/sanctum/control/run/agent-monday/{broca2,thalamus}
mkdir -p ~/sanctum/control/run/agent-timbre/{broca2,thalamus}

# Create placeholder requirements.txt
cat > ~/sanctum/requirements.txt <<EOF
# Global Sanctum requirements
# Auto-generated by control system update mechanism
# Consolidates all module requirements into global venv

# Placeholder - will be populated by actual modules
EOF

echo "‚úî Created Sanctum folder structure"

############################################
# 4. Pre-certificate sanity checks
############################################
echo -e "\n=== Running pre-certificate sanity checks ==="

# Check if ports 80 and 443 are available
echo "Checking port listeners..."
if ss -tlnp | grep -q ":80 "; then
    if ss -tlnp | grep ":80 " | grep -vq nginx; then
        echo "‚ùå Port 80 in use by non-nginx"
        ss -tlnp | grep ":80 "
        exit 1
    else
        echo "‚úî Port 80 in use by nginx (OK)"
    fi
else
    echo "‚úî Port 80 free"
fi

if ss -tlnp | grep -q ":443 "; then
    if ss -tlnp | grep ":443 " | grep -vq nginx; then
        echo "‚ùå Port 443 in use by non-nginx"
        ss -tlnp | grep ":443 "
        exit 1
    else
        echo "‚úî Port 443 in use by nginx (OK)"
    fi
else
    echo "‚úî Port 443 free"
fi

# Check if domain resolves
echo "Checking domain resolution..."
if getent hosts "$DOMAIN" >/dev/null; then
    echo "‚úî Domain $DOMAIN resolves correctly"
else
    echo "‚ùå Domain $DOMAIN does not resolve"
    exit 1
fi

# Check if Letta container is running and healthy
echo "Checking Letta container status..."
echo "Waiting for Letta to fully initialize (this can take up to 2 minutes)..."

for attempt in 1 2 3 4 5 6 7 8 9 10; do
    echo -n "Attempt $attempt/10: "
    
    # First check if container exists
    if ! docker ps | grep -q $LETTA_IMAGE; then
        echo "Container not running yet"
        if [ $attempt -lt 10 ]; then
            echo "Waiting 15 seconds before retry..."
            sleep 15
            continue
        else
            echo "‚ùå Letta container failed to start after 10 attempts (2.5 minutes)"
            exit 1
        fi
    fi
    
    # Container exists, now check health
    echo "Container running, checking health..."
    for i in {1..15}; do
        if curl -s http://localhost:$LETTA_HOST_PORT/v1/health/ >/dev/null 2>&1; then
            echo "‚úî Letta is healthy and responding"
            break 2
        fi
        
        # Simple spinner
        case $((i % 4)) in
            0) printf "\r[‚†ã] Checking health... " ;;
            1) printf "\r[‚†ô] Checking health... " ;;
            2) printf "\r[‚†π] Checking health... " ;;
            3) printf "\r[‚†∏] Checking health... " ;;
        esac
        sleep 1
    done
    
    # Clear the spinner line
    printf "\r%-50s\r" ""
    
    if [ $attempt -lt 10 ]; then
        echo -e "\nLetta not ready yet, waiting 15 seconds before retry..."
        sleep 15
    fi
done

# Final check
if ! curl -s http://localhost:$LETTA_HOST_PORT/v1/health/ >/dev/null 2>&1; then
    echo "‚ùå Letta failed to become healthy after 3 attempts"
    echo "Container logs:"
    docker logs $(docker ps -q --filter "ancestor=$LETTA_IMAGE") 2>/dev/null || echo "Could not retrieve logs"
    exit 1
fi

# Check if Nginx is running
echo "Checking Nginx status..."
if systemctl is-active --quiet nginx; then
    echo "‚úî Nginx is running"
else
    echo "‚ùå Nginx is not running"
    exit 1
fi

echo "‚úî All sanity checks passed"

############################################
# 5. TEMPORARY HTTP-ONLY site (needed before Certbot)
############################################
cat >$NGINX_SITES_AVAILABLE/$DOMAIN <<EOF
server {
    listen 80;
    server_name $DOMAIN;
    location / { proxy_pass http://127.0.0.1:$LETTA_HOST_PORT; }
}
EOF
ln -sf $NGINX_SITES_AVAILABLE/$DOMAIN $NGINX_SITES_ENABLED/$DOMAIN
nginx -t && systemctl reload nginx          # must pass

############################################
# 6. Obtain certificate & upgrade site to HTTPS
############################################
certbot --nginx -d $DOMAIN \
        --non-interactive --agree-tos --redirect \
        -m $EMAIL

# Ensure nginx reloads on certificate renewal
mkdir -p /etc/letsencrypt/renewal-hooks/deploy
cat > /etc/letsencrypt/renewal-hooks/deploy/reload-nginx.sh <<'EOF'
#!/bin/bash
systemctl reload nginx
EOF
chmod +x /etc/letsencrypt/renewal-hooks/deploy/reload-nginx.sh

############################################
# 7. Overwrite site with FINAL SSL + ADE-CORS config
############################################
cat >$NGINX_SITES_AVAILABLE/$DOMAIN <<'NGINX'
server {
    listen 80;
    server_name DOMAIN_PLACEHOLDER;
    return 301 https://$host$request_uri;
}
server {
    listen 443 ssl http2;
    server_name DOMAIN_PLACEHOLDER;

    ssl_certificate /etc/letsencrypt/live/DOMAIN_PLACEHOLDER/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/DOMAIN_PLACEHOLDER/privkey.pem;
    include /etc/letsencrypt/options-ssl-nginx.conf;
    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;
    
    # Upload size limit
    client_max_body_size 100m;

    location / {
        proxy_pass http://127.0.0.1:PORT_PLACEHOLDER;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # Streaming safety
        proxy_read_timeout 3600;
        proxy_send_timeout 3600;
    }

    location /v1/ {
        # DEBUG: Log all requests to this location
        access_log /var/log/nginx/v1_access.log;
        error_log /var/log/nginx/v1_error.log;

        # Handle preflight OPTIONS request
        if ($request_method = OPTIONS) {
            add_header Access-Control-Allow-Origin "*" always;
            add_header Access-Control-Allow-Methods "GET, POST, OPTIONS, PUT, DELETE, HEAD" always;
            add_header Access-Control-Allow-Headers "Authorization, Content-Type, X-Bare-Password, Cache-Control, Accept, X-Requested-With, Sec-Ch-Ua, Sec-Ch-Ua-Mobile, Sec-Ch-Ua-Platform, Sec-Fetch-Site, Sec-Fetch-Mode, Sec-Fetch-Dest, Sec-Fetch-User, Sec-Fetch-Header, X-Source-Client" always;
            add_header Access-Control-Allow-Credentials "true" always;
            add_header Access-Control-Max-Age "86400" always;
            return 204;
        }

        # Hide any existing CORS headers from upstream
        proxy_hide_header Access-Control-Allow-Origin;
        proxy_hide_header Access-Control-Allow-Methods;
        proxy_hide_header Access-Control-Allow-Headers;
        proxy_hide_header Access-Control-Allow-Credentials;

        # Allow all origins for now (you can restrict this later)
        add_header Access-Control-Allow-Origin "*" always;
        add_header Access-Control-Allow-Methods "GET, POST, OPTIONS, PUT, DELETE, HEAD" always;
        add_header Access-Control-Allow-Headers "Authorization, Content-Type, X-Bare-Password, Cache-Control, Accept, X-Requested-With, Sec-Ch-Ua, Sec-Ch-Ua-Mobile, Sec-Ch-Ua-Platform, Sec-Fetch-Site, Sec-Fetch-Mode, Sec-Fetch-Dest, Sec-Fetch-User, Sec-Fetch-Header, X-Source-Client" always;
        add_header Access-Control-Allow-Credentials "true" always;

        proxy_pass http://127.0.0.1:PORT_PLACEHOLDER;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # Streaming safety
        proxy_read_timeout 3600;
        proxy_send_timeout 3600;
    }

    location /ui/ {
        proxy_pass http://localhost:5000/;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # Streaming safety
        proxy_read_timeout 3600;
        proxy_send_timeout 3600;
    }
}
NGINX
sed -i "s/DOMAIN_PLACEHOLDER/$DOMAIN/g; s/PORT_PLACEHOLDER/$LETTA_HOST_PORT/g" $NGINX_SITES_AVAILABLE/$DOMAIN
nginx -t && systemctl reload nginx

############################################
# 8. Final verification
############################################
echo -e "\n=== Hitting /v1/health/ ==="
curl -fk https://$DOMAIN/v1/health/ && echo -e "\n‚úî Completed"

############################################
# 9. Send SIGINT to Letta screen session
############################################
echo -e "\n=== Sending SIGINT to Letta screen session ==="
screen -S $SCREEN_SESSION -X stuff $'\003'
echo "‚úî Sent SIGINT to Letta"

############################################
# 10. Create auto-start launch script
############################################
echo -e "\n=== Creating auto-start launch script ==="

cat > ~/launch_letta.sh <<'EOF'
#!/bin/bash

SESSION_NAME="letta"

# Optional: load env vars from a .env file for better secret hygiene
source ~/.letta/.env

CMD="docker run \
  -v ~/.letta/.persist/pgdata:/var/lib/postgresql/data \
  -p 8284:8283 \
  --env-file ~/.letta/.env \
  -e SECURE=true \
  -e LETTA_SERVER_PASSWORD=\"$LETTA_SERVER_PASSWORD\" \
  --add-host=host.docker.internal:host-gateway \
  letta/letta:latest"

# Launch in a detached screen session
screen -dmS $SESSION_NAME bash -c "$CMD"

# Run directly for troubleshooting
# bash -c "$CMD"
EOF

chmod +x ~/launch_letta.sh
echo "‚úî Created launch script: ~/launch_letta.sh"

############################################
# 11. Add to crontab for auto-start
############################################
echo -e "\n=== Adding launch script to crontab ==="

# Get current crontab or create empty one
CURRENT_CRON=$(crontab -l 2>/dev/null || echo "")

# Check if already in crontab
if echo "$CURRENT_CRON" | grep -q "launch_letta.sh"; then
    echo "‚úî Launch script already in crontab"
else
    # Add @reboot entry with absolute path
    NEW_CRON="$CURRENT_CRON
@reboot $HOME/launch_letta.sh"
    
    # Write new crontab
    echo "$NEW_CRON" | crontab -
    
    # Verify it was added
    if crontab -l | grep -q "launch_letta.sh"; then
        echo "‚úî Added @reboot entry to crontab"
        echo "Current crontab:"
        crontab -l
    else
        echo "‚ùå Failed to add to crontab!"
        exit 1
    fi
fi

############################################
# 12. Create Flask control panel
############################################
echo -e "\n=== Creating Flask control panel ==="

# Create Flask app directory
mkdir -p ~/sanctum/control/web

# Create dummy Flask app
cat > ~/sanctum/control/web/app.py <<'FLASK_EOF'
#!/usr/bin/env python3
from flask import Flask, render_template_string

app = Flask(__name__)

@app.route('/')
def index():
    html = """
    <!DOCTYPE html>
    <html>
    <head>
        <title>Sanctum Control Panel</title>
        <style>
            body { font-family: Arial, sans-serif; margin: 40px; background: #f5f5f5; }
            .container { max-width: 800px; margin: 0 auto; background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
            h1 { color: #333; text-align: center; }
            .status { background: #e8f5e8; padding: 15px; border-radius: 5px; margin: 20px 0; }
            .info { background: #e3f2fd; padding: 15px; border-radius: 5px; margin: 20px 0; }
        </style>
    </head>
    <body>
        <div class="container">
            <h1>üöÄ Sanctum Control Panel</h1>
            <div class="status">
                <h3>‚úÖ Status: Running</h3>
                <p>Flask app is successfully running on localhost:5000</p>
                <p>Proxied via Nginx at /ui/</p>
            </div>
            <div class="info">
                <h3>üìÅ Location</h3>
                <p><strong>App:</strong> ~/sanctum/control/web/app.py</p>
                <p><strong>Launch Script:</strong> ~/sanctum/control/run/start-flask.sh</p>
                <p><strong>Port:</strong> 5000 (localhost only)</p>
            </div>
        </div>
    </body>
    </html>
    """
    return html

if __name__ == '__main__':
    app.run(host='127.0.0.1', port=5000, debug=False)
FLASK_EOF

# Create Flask launch script in control/run (following Sanctum pattern)
cat > ~/sanctum/control/run/run-ui.sh <<'EOF'
#!/usr/bin/env bash
set -euo pipefail

# Launch Flask UI in detached screen session
screen -dmS ui ~/sanctum/venv/bin/python ~/sanctum/control/web/app.py

# Run directly for troubleshooting (commented out)
# cd ~/sanctum/control/web
# exec ~/sanctum/venv/bin/python app.py
EOF

chmod +x ~/sanctum/control/run/run-ui.sh

# Verify files were created
echo "Verifying Flask files were created:"
ls -la ~/sanctum/control/web/
ls -la ~/sanctum/control/run/run-ui.sh

echo "‚úî Created Flask app and launch script in control/run"

############################################
# 13. Launch Flask UI in screen session
############################################
echo -e "\n=== Launching Flask UI in screen session ==="

# Launch Flask UI in detached screen session (same as Letta)
screen -dmS ui ~/sanctum/control/run/run-ui.sh
echo "‚úî Flask UI launched in screen session 'ui'"

############################################
# 14. Add Flask to crontab for auto-start
############################################
echo -e "\n=== Adding Flask to crontab for auto-start ==="

# Get current crontab or create empty one
CURRENT_CRON=$(crontab -l 2>/dev/null || echo "")

# Check if Flask is already in crontab
if echo "$CURRENT_CRON" | grep -q "run-ui.sh"; then
    echo "‚úî Flask already in crontab"
else
    # Add @reboot entry with absolute path
    NEW_CRON="$CURRENT_CRON
@reboot $HOME/sanctum/control/run/run-ui.sh"
    
    # Write new crontab
    echo "$NEW_CRON" | crontab -
    
    # Verify it was added
    if crontab -l | grep -q "run-ui.sh"; then
        echo "‚úî Added Flask @reboot entry to crontab"
        echo "Current crontab:"
        crontab -l
    else
        echo "‚ùå Failed to add Flask to crontab!"
        exit 1
    fi
fi
